---
title: "MomoPopsMilanoDEM_Sampling"
author: "Walker Crane"
date: "2023-07-24"
output: html_document
---

# Hay Patch clipping raster data, creating GeoTiff, plotting Raster with property boundaries
```{r}
# Step 1: Load the required libraries
library(raster)
library(rgdal)
library(ggplot2)
library(scales)
library(sf)
library(sp)
library(terra)
library(rasterVis)

# Step 2: Read the raster data and land parcel polygon shapefile
#raster_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/USGS_one_meter_x69y340_TX_Eastern_B1_2018.tif"
raster_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/USGS_13_n31w097_20191107.tif"
parcel_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/stratmap22-landparcels_48331_milam_202202.shp"

raster_data <- raster(raster_path)
parcel_data <- readOGR(parcel_path)

# Hay Patch Boundary
# Replace these values with your DMS coordinates for the five points
lon_deg <- c(96, 96, 96, 96, 96)
lon_min <- c(56, 56, 56, 56,56)
lon_sec <- c(14.83, 7.81, 7.55, 1.45)
lon_dir <- rep("W", 4)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30, 30)
lat_min <- c(44,43,44,44)
lat_sec <- c(14.96,56.33,1.94,19.21)
lat_dir <- rep("N", 4)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create an sf polygon object from the five points (assumes a closed polygon)
haypatch_boundary <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[1], lat_dd[1]))))

haypatch_boundary_Poly <- Polygon(haypatch_boundary)
haypatch_boundary_Poly_ps <- Polygons(list(haypatch_boundary_Poly),1)
haypatch_boundary_Poly_sps <- SpatialPolygons(list(haypatch_boundary_Poly_ps))
plot(haypatch_boundary_Poly_sps)
proj4string(haypatch_boundary_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_haypatch = SpatialPolygonsDataFrame(haypatch_boundary_Poly_sps,data)
spdf_haypatch

# Set as simple feature
spdf_haypatch_sf <- st_as_sf(spdf_haypatch)
plot(spdf_haypatch_sf)

#Hay Patch Tank
# Replace these values with your DMS coordinates for the four points
lon_deg <- c(96, 96, 96, 96, 96)
lon_min <- c(56, 56, 56, 56,56)
lon_sec <- c(11.37,10.12,9.92,11.17)
lon_dir <- rep("W", 4)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30, 30)
lat_min <- c(44,44,44,44)
lat_sec <- c(14.72,15.01,13.15,13.14)
lat_dir <- rep("N", 4)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create an sf polygon object from the five points (assumes a closed polygon)
haypatch_tank_boundary <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[1], lat_dd[1]))))

haypatch_tank_boundary_Poly <- Polygon(haypatch_tank_boundary)
haypatch_tank_boundary_Poly_ps <- Polygons(list(haypatch_tank_boundary_Poly),1)
haypatch_tank_boundary_Poly_sps <- SpatialPolygons(list(haypatch_tank_boundary_Poly_ps))
plot(haypatch_tank_boundary_Poly_sps)
proj4string(haypatch_tank_boundary_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_haypatch_tank = SpatialPolygonsDataFrame(haypatch_tank_boundary_Poly_sps,data)
spdf_haypatch_tank

# Set as simple feature
spdf_haypatch_tank_sf <- st_as_sf(spdf_haypatch_tank)

#Hay Patch Woods North
# Replace these values with your DMS coordinates for the four points
lon_deg <- c(96, 96, 96, 96, 96)
lon_min <- c(56, 56, 56, 56,56)
lon_sec <- c(5.34,6.94,10.08,9.49)
lon_dir <- rep("W", 4)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30, 30)
lat_min <- c(44,44,44,44)
lat_sec <- c(17.95,12.93,12.32,16.65)
lat_dir <- rep("N", 4)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create an sf polygon object from the five points (assumes a closed polygon)
haypatch_woods_boundary <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[1], lat_dd[1]))))

haypatch_woods_boundary_Poly <- Polygon(haypatch_woods_boundary)
haypatch_woods_boundary_Poly_ps <- Polygons(list(haypatch_woods_boundary_Poly),1)
haypatch_woods_boundary_Poly_sps <- SpatialPolygons(list(haypatch_woods_boundary_Poly_ps))
plot(haypatch_woods_boundary_Poly_sps)
proj4string(haypatch_woods_boundary_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_haypatch_woods = SpatialPolygonsDataFrame(haypatch_woods_boundary_Poly_sps,data)
spdf_haypatch_woods

# Set as simple feature
spdf_haypatch_woods_sf <- st_as_sf(spdf_haypatch_woods)

#Hay Patch Woods South
# Replace these values with your DMS coordinates for the four points
lon_deg <- c(96, 96, 96, 96, 96)
lon_min <- c(56, 56, 56, 56,56)
lon_sec <- c(14.20,12.68,10.13, 10.84)
lon_dir <- rep("W", 4)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30, 30)
lat_min <- c(44,44,44,44)
lat_sec <- c(13.23,11.43,10.93,4.26)
lat_dir <- rep("N", 4)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create an sf polygon object from the five points (assumes a closed polygon)
haypatch_woods_1_boundary <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[1], lat_dd[1]))))

haypatch_woods_1_boundary_Poly <- Polygon(haypatch_woods_1_boundary)
haypatch_woods_1_boundary_Poly_ps <- Polygons(list(haypatch_woods_1_boundary_Poly),1)
haypatch_woods_1_boundary_Poly_sps <- SpatialPolygons(list(haypatch_woods_1_boundary_Poly_ps))
plot(haypatch_woods_1_boundary_Poly_sps)
proj4string(haypatch_woods_1_boundary_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_haypatch_woods_1 = SpatialPolygonsDataFrame(haypatch_woods_1_boundary_Poly_sps,data)
spdf_haypatch_woods_1 

# Set as simple feature
spdf_haypatch_woods_1_sf <- st_as_sf(spdf_haypatch_woods_1)

# Step 4: Convert raster data to a data frame
raster_df <- as.data.frame(raster_data, xy = TRUE)
raster_df$Elev_Feet <- raster_df$Layer_1*3.28084

# Step 6: Clip the raster using the land parcel polygon
raster_clip <- crop(raster_data, st_buffer(spdf_haypatch_sf, dist = 20))
raster_clip <- raster_clip*3.28084

# Step 7: Save the raster layer to a Geotiff file
writeRaster(raster_clip, filename = "raster_Haypatch_prop.tif", format = "GTiff", overwrite= TRUE)

# Step 8; Load DEM tiff
elevation_haypatch <- raster("raster_Haypatch_prop.tif")

# Convert the raster data to a data.frame
elevation_haypatch_df <- raster::rasterToPoints(elevation_haypatch)
elevation_haypatch_df <- as.data.frame(elevation_haypatch_df)
plot(raster_clip)

# Define the sampling area within the property boundaries (can be the entire property or a specific region)
sampling_area <- spdf_haypatch_sf
sampling_area <- st_transform(sampling_area, st_crs(spdf_haypatch_sf))

# Now both sampling_area and pond_boundary_Poly_sps have the same CRS, and st_difference should work without any errors.
sampling_area_excluded <- st_difference(sampling_area, spdf_haypatch_tank_sf)
sampling_area_excluded <- st_difference(sampling_area_excluded, spdf_haypatch_woods_sf)
sampling_area_excluded <- st_difference(sampling_area_excluded, spdf_haypatch_woods_1_sf)
plot(sampling_area_excluded)

# Generate sampling points within the updated sampling area (excluding pond and woods)
sampling_points_final <- st_sample(sampling_area_excluded, type = "regular", size = 15)

# Convert the sampling points to a data.frame with separate columns for longitude (X) and latitude (Y)
sampling_points_df_final <- as.data.frame(st_coordinates(sampling_points_final))
names(sampling_points_df_final) <- c("X", "Y")  # Rename columns for clarity

# Add DMS coordinates to sampling_points_df_final data frame
sampling_points_df_final$Longitude_DMS <- decimal_to_dms_with_directions(sampling_points_df_final$X, "x")
sampling_points_df_final$Latitude_DMS <- decimal_to_dms_with_directions(sampling_points_df_final$Y, "y")

# Add a new column "Sample_Number" to the sampling_points_df_final data frame with the sampling numbers
sampling_points_df_final$Sample_Number <- 1:nrow(sampling_points_df_final)

#Create .csv file with sample points, coordinates, and number
HayPatchSamplingPoints <- write.csv(sampling_points_df_final, "HayPatchSamplingPoints.csv")


# Calculate the centroid of the polygon
tank_centroid <- st_centroid(spdf_haypatch_tank_sf)

tank_centroid_df <- st_coordinates(tank_centroid) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))

# Calculate the centroid of the polygon
woods_centroid <- st_centroid(spdf_haypatch_woods_sf)

woods_centroid_df <- st_coordinates(woods_centroid) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))

# Calculate the centroid of the polygon
woods_1_centroid <- st_centroid(spdf_haypatch_woods_1_sf)

woods_1_centroid_df <- st_coordinates(woods_1_centroid) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))


# Manually specify the four specific values for the breaks on the x-axis
breaks_x <- c(-96.9365, -96.9355, -96.9345)


# Plot the shapefile with ggplot2 and add the raster data as a background layer
HayPatch<- ggplot() +
  geom_raster(data = elevation_haypatch_df, aes(x = x, y = y, fill = raster_Haypatch_prop)) +    # Plot the raster data
  geom_sf(data = spdf_haypatch_sf, color = "black", fill = "transparent") +       # Plot the shapefile
  geom_polygon(data = haypatch_tank_boundary, aes(x = X1, y = X2), fill = "lightblue") +
  geom_text(data = tank_centroid_df, aes(x = X, y = Y, label = "TANK"), color = "black", angle = 75) +
  geom_polygon(data = haypatch_woods_boundary, aes(x = X1, y = X2), fill = "orange") +
  geom_text(data = woods_centroid_df, aes(x = X, y = Y, label = "WOODS"), color = "black") +
  geom_polygon(data = haypatch_woods_1_boundary, aes(x = X1, y = X2), fill = "orange") +
  geom_text(data = woods_1_centroid_df, aes(x = X, y = Y, label = "WOODS"), color = "black", angle = 90) +
  geom_point(data = sampling_points_df_final, aes(x = X, y = Y), color = "red", size = 2) +  # Plot the final sampling points
  geom_text(data = sampling_points_df_final, aes(x = X, y = Y, label = Sample_Number), 
            color = "black", vjust = 0, hjust = -0.5) +                # Adding labels to the sampling points
  scale_fill_viridis_c() +                                                              # Use Viridis color scale (you can change this)
  coord_sf(crs = st_crs(spdf_haypatch_sf)) +                                     # Set the coordinate system for the plot
  labs(x = "Longitude", y = "Latitude", fill = "Elevation (ft)", title = "Hay Patch DEM w/ Sampling Locations") +
  # Add the following line to set the desired breaks on the x-axis
  scale_x_continuous(labels = function(x) decimal_to_dms_with_directions(x, "x"), 
                     breaks = breaks_x, expand = c(0, 0)) +
  scale_y_continuous(labels = function(y) decimal_to_dms_with_directions(y, "y"), expand = c(0, 0)) +  # Use custom labeling for Y-axis
  theme(axis.title.x = element_text(size = 12, color = "black"),
        axis.text.x = element_text(size = 7, color = "black"),
        axis.title.y = element_text(size = 12, color = "black"),
        axis.text.y = element_text(size = 7, color = "black"),
        legend.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.justification = "center", 
        plot.title = element_text(hjust = 0.5))
HayPatch

ggsave("DEM_Sampling_HayPatch.jpeg", HayPatch ,height = 7, width = 7, dpi = 300)
```

#Main Pasture
```{r}
# Step 1: Load the required libraries
library(raster)
library(rgdal)
library(ggplot2)
library(scales)
library(sf)
library(sp)
library(terra)
library(rasterVis)
library(ggspatial)

# Step 2: Read the raster data and land parcel polygon shapefile
#raster_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/USGS_one_meter_x69y340_TX_Eastern_B1_2018.tif"
raster_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/USGS_13_n31w097_20191107.tif"
parcel_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/stratmap22-landparcels_48331_milam_202202.shp"

raster_data <- raster(raster_path)
parcel_data <- readOGR(parcel_path)

# Prop_ID values to match
prop_num <- c(58839)

# Use %in% to filter rows
morgan_prop <- parcel_data[parcel_data$Prop_ID %in% prop_num, ]

# Step 3: Set the CRS of the shapefile to match the CRS of the raster
proj4string(morgan_prop) <- CRS("+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")
proj4string(morgan_prop)
projection(raster_data) <- CRS("+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")
projection(raster_data)

morgan_prop_sf <- st_as_sf(morgan_prop)
sampling_area <- morgan_prop_sf

#####################################################################################
# Function to convert decimal degrees to DMS format with cardinal directions
decimal_to_dms_with_directions <- function(decimal_degrees, axis) {
  degrees <- floor(abs(decimal_degrees))
  minutes <- floor((abs(decimal_degrees) - degrees) * 60)
  seconds <- round((abs(decimal_degrees) - degrees - minutes/60) * 3600, 2)
  
  direction <- ifelse(axis == "x", ifelse(decimal_degrees < 0, "W", "E"), ifelse(decimal_degrees < 0, "S", "N"))
  
  return(paste0(degrees, "°", minutes, "'", seconds, "\" ", direction))
}

#####################################################################################
# Function to convert DMS (Degrees-Minutes-Seconds) to decimal degrees (DD)
dms_to_dd <- function(degrees, minutes, seconds, direction) {
  sign <- ifelse(direction %in% c("S", "W"), -1, 1)
  dd <- sign * (abs(degrees) + minutes / 60 + seconds / 3600)
  return(dd)
}

# Function to convert meters to decimal degrees
meters_to_dd <- function(meters, latitude) {
  # Earth's radius in meters
  earth_radius <- 6378137
  
  # Conversion factor (approximation for small distances)
  meters_per_degree <- (2 * pi * earth_radius) / 360
  
  # Calculate the distance in decimal degrees
  dd <- meters / meters_per_degree
  
  return(dd)
}
#####################################################################################
# Creating function to create number of samples per area
set_sampling_points <- function(polygon_sf) {
  # Get the total area of the polygon in acres from the "GIS_AREA" column
  total_area_acres <- sum(polygon_sf$GIS_AREA)
  
  # Set the number of sampling points based on the area criteria
  if (total_area_acres <= 1) {
    num_sampling_points <- 10
  } else if (total_area_acres > 1 & total_area_acres <= 5) {
    num_sampling_points <- round(total_area_acres * 2)
  } else if (total_area_acres > 5 & total_area_acres <= 20) {
    num_sampling_points <- round(total_area_acres / 2)
  } else {
    num_sampling_points <- round(total_area_acres/10)
  }
  
  return(num_sampling_points)
}

# Assuming you have the "morgan_prop_sf" data frame with the column "GIS_AREA"
num_sampling_points <- set_sampling_points(sampling_area)

print(num_sampling_points)  # This will give you the number of sampling points based on the area of the polygons and the specified criteria

####################################################################################
# Step 4: Convert raster data to a data frame
raster_df <- as.data.frame(raster_data, xy = TRUE)

# Step 5: Convert parcel_data to an sf object
sampling_area <- st_as_sf(morgan_prop)
crs(sampling_area)

#####################################################################################################################################
# Buffer distance in meters
buffer_distance_meters <- 30

#Pond 1
# Example of pond_location in DMS format
lon_deg_pond1 <- 96
lon_min_pond1 <- 56
lon_sec_pond1 <- 7.35
lon_dir_pond1 <- "W"  # West (use "E" for East)

lat_deg_pond1 <- 30
lat_min_pond1 <- 44
lat_sec_pond1 <- 39.42
lat_dir_pond1 <- "N"  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude
lon_pond_dd_pond1 <- dms_to_dd(lon_deg_pond1, lon_min_pond1, lon_sec_pond1, lon_dir_pond1)
lat_pond_dd_pond1 <- dms_to_dd(lat_deg_pond1, lat_min_pond1, lat_sec_pond1, lat_dir_pond1)

# Convert buffer distance from meters to decimal degrees
buffer_distance_dd_pond1 <- meters_to_dd(buffer_distance_meters, lat_pond_dd_pond1)

# Create the pond_location as a point in sf format
pond_central_point_pond1 <- st_point(c(lon_pond_dd_pond1, lat_pond_dd_pond1))

# Add a buffer of 50 meters around the pond_central_point
pond_buffer_pond1 <- st_buffer(pond_central_point_pond1, dist = buffer_distance_dd_pond1, crs = "+init=epsg:4326")

# Extract the x (longitude) and y (latitude) coordinates from the circle
circle_coords_pond1 <- st_coordinates(pond_buffer_pond1)

# Create a dataframe with the circle coordinates
circle_df_pond1 <- data.frame(lon = circle_coords_pond1[, "X"], lat = circle_coords_pond1[, "Y"])

pond_boundary_Poly_pond1 <- Polygon(circle_df_pond1)
pond_boundary_Poly_ps_pond1 <- Polygons(list(pond_boundary_Poly_pond1),1)
pond_boundary_Poly_sps_pond1 <- SpatialPolygons(list(pond_boundary_Poly_ps_pond1))
plot(pond_boundary_Poly_sps_pond1)
proj4string(pond_boundary_Poly_sps_pond1) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

data = data.frame(f=99.9)
spdf_pond_pond1 = SpatialPolygonsDataFrame(pond_boundary_Poly_sps_pond1,data)
spdf_pond_pond1
summary(spdf_pond_pond1)

spdf_pond_pond1 <- st_as_sf(spdf_pond_pond1)
spdf_pond_pond1 <- st_transform(spdf_pond_pond1, st_crs(sampling_area))


#Pond 2
# Example of pond_location in DMS format
lon_deg_pond2 <- 96
lon_min_pond2 <- 55
lon_sec_pond2 <- 46.50
lon_dir_pond2 <- "W"  # West (use "E" for East)

lat_deg_pond2 <- 30
lat_min_pond2 <- 44
lat_sec_pond2 <- 24.62
lat_dir_pond2 <- "N"  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude
lon_pond_dd_pond2 <- dms_to_dd(lon_deg_pond2, lon_min_pond2, lon_sec_pond2, lon_dir_pond2)
lat_pond_dd_pond2 <- dms_to_dd(lat_deg_pond2, lat_min_pond2, lat_sec_pond2, lat_dir_pond2)

# Convert buffer distance from meters to decimal degrees
buffer_distance_dd_pond2 <- meters_to_dd(buffer_distance_meters, lat_pond_dd_pond2)

# Create the pond_location as a point in sf format
pond_central_point_pond2 <- st_point(c(lon_pond_dd_pond2, lat_pond_dd_pond2))

# Add a buffer of 50 meters around the pond_central_point
pond_buffer_pond2 <- st_buffer(pond_central_point_pond2, dist = buffer_distance_dd_pond2, crs = "+init=epsg:4326")

# Extract the x (longitude) and y (latitude) coordinates from the circle
circle_coords_pond2 <- st_coordinates(pond_buffer_pond2)

# Create a dataframe with the circle coordinates
circle_df_pond2 <- data.frame(lon = circle_coords_pond2[, "X"], lat = circle_coords_pond2[, "Y"])

pond_boundary_Poly_pond2 <- Polygon(circle_df_pond2)
pond_boundary_Poly_ps_pond2 <- Polygons(list(pond_boundary_Poly_pond2),1)
pond_boundary_Poly_sps_pond2 <- SpatialPolygons(list(pond_boundary_Poly_ps_pond2))
plot(pond_boundary_Poly_sps_pond2)
proj4string(pond_boundary_Poly_sps_pond2) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

data = data.frame(f=99.9)
spdf_pond_pond2 = SpatialPolygonsDataFrame(pond_boundary_Poly_sps_pond2,data)
spdf_pond_pond2
summary(spdf_pond_pond2)

spdf_pond_pond2 <- st_as_sf(spdf_pond_pond2)
spdf_pond_pond2 <- st_transform(spdf_pond_pond2, st_crs(sampling_area))

# Assuming you have loaded the 'sf' library and have your polygons defined.

# Crop 'polygon_to_crop' using 'cropping_polygon'
cropped_pond2 <- st_intersection(spdf_pond_pond2, sampling_area)
cropped_pond2 <- st_as_sf(cropped_pond2)

#Pond 3
# Example of pond_location in DMS format
lon_deg_pond3 <- 96
lon_min_pond3 <- 55
lon_sec_pond3 <- 45.82
lon_dir_pond3 <- "W"  # West (use "E" for East)

lat_deg_pond3 <- 30
lat_min_pond3 <- 44
lat_sec_pond3 <- 27.42
lat_dir_pond3 <- "N"  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude
lon_pond_dd_pond3 <- dms_to_dd(lon_deg_pond3, lon_min_pond3, lon_sec_pond3, lon_dir_pond3)
lat_pond_dd_pond3 <- dms_to_dd(lat_deg_pond3, lat_min_pond3, lat_sec_pond3, lat_dir_pond3)

# Convert buffer distance from meters to decimal degrees
buffer_distance_dd_pond3 <- meters_to_dd(buffer_distance_meters, lat_pond_dd_pond3)

# Create the pond_location as a point in sf format
pond_central_point_pond3 <- st_point(c(lon_pond_dd_pond3, lat_pond_dd_pond3))

# Add a buffer of 50 meters around the pond_central_point
pond_buffer_pond3 <- st_buffer(pond_central_point_pond3, dist = buffer_distance_dd_pond3, crs = "+init=epsg:4326")

# Extract the x (longitude) and y (latitude) coordinates from the circle
circle_coords_pond3 <- st_coordinates(pond_buffer_pond3)

# Create a dataframe with the circle coordinates
circle_df_pond3 <- data.frame(lon = circle_coords_pond3[, "X"], lat = circle_coords_pond3[, "Y"])

pond_boundary_Poly_pond3 <- Polygon(circle_df_pond3)
pond_boundary_Poly_ps_pond3 <- Polygons(list(pond_boundary_Poly_pond3),1)
pond_boundary_Poly_sps_pond3 <- SpatialPolygons(list(pond_boundary_Poly_ps_pond3))
plot(pond_boundary_Poly_sps_pond3)
proj4string(pond_boundary_Poly_sps_pond3) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

data = data.frame(f=99.9)
spdf_pond_pond3 = SpatialPolygonsDataFrame(pond_boundary_Poly_sps_pond3,data)
spdf_pond_pond3
summary(spdf_pond_pond3)

spdf_pond_pond3 <- st_as_sf(spdf_pond_pond3)
spdf_pond_pond3 <- st_transform(spdf_pond_pond3, st_crs(sampling_area))

#Pond 4
# Example of pond_location in DMS format
lon_deg_pond4 <- 96
lon_min_pond4 <- 55
lon_sec_pond4 <- 48.26
lon_dir_pond4 <- "W"  # West (use "E" for East)

lat_deg_pond4 <- 30
lat_min_pond4 <- 44
lat_sec_pond4 <- 42.25
lat_dir_pond4 <- "N"  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude
lon_pond_dd_pond4 <- dms_to_dd(lon_deg_pond4, lon_min_pond4, lon_sec_pond4, lon_dir_pond4)
lat_pond_dd_pond4 <- dms_to_dd(lat_deg_pond4, lat_min_pond4, lat_sec_pond4, lat_dir_pond4)

# Convert buffer distance from meters to decimal degrees
buffer_distance_dd_pond4 <- meters_to_dd(buffer_distance_meters, lat_pond_dd_pond4)

# Create the pond_location as a point in sf format
pond_central_point_pond4 <- st_point(c(lon_pond_dd_pond4, lat_pond_dd_pond4))

# Add a buffer of 50 meters around the pond_central_point
pond_buffer_pond4 <- st_buffer(pond_central_point_pond4, dist = buffer_distance_dd_pond4, crs = "+init=epsg:4326")

# Extract the x (longitude) and y (latitude) coordinates from the circle
circle_coords_pond4 <- st_coordinates(pond_buffer_pond4)

# Create a dataframe with the circle coordinates
circle_df_pond4 <- data.frame(lon = circle_coords_pond4[, "X"], lat = circle_coords_pond4[, "Y"])

pond_boundary_Poly_pond4 <- Polygon(circle_df_pond4)
pond_boundary_Poly_ps_pond4 <- Polygons(list(pond_boundary_Poly_pond4),1)
pond_boundary_Poly_sps_pond4 <- SpatialPolygons(list(pond_boundary_Poly_ps_pond4))
plot(pond_boundary_Poly_sps_pond4)
proj4string(pond_boundary_Poly_sps_pond4) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

data = data.frame(f=99.9)
spdf_pond_pond4 = SpatialPolygonsDataFrame(pond_boundary_Poly_sps_pond4,data)
spdf_pond_pond4
summary(spdf_pond_pond4)

spdf_pond_pond4 <- st_as_sf(spdf_pond_pond4)
spdf_pond_pond4 <- st_transform(spdf_pond_pond4, st_crs(sampling_area))

#################################################################################################################
# Cattle Lot
# Replace these values with your DMS coordinates for the five points
lon_deg <- c(96, 96, 96, 96)
lon_min <- c(55, 55, 55, 55)
lon_sec <- c(47.96, 48.06, 46.91, 46.82)
lon_dir <- rep("W", 4)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30)
lat_min <- c(44, 44, 44, 44)
lat_sec <- c(30.28,29.40,29.31,30.19)
lat_dir <- rep("N", 4)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create a dataframe for lot' coordinates
# Create an sf polygon object from the five points (assumes a closed polygon)
cattle_lot <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[1], lat_dd[1]))))

cattle_lot_Poly <- Polygon(cattle_lot)
cattle_lot_Poly_ps <- Polygons(list(cattle_lot_Poly),1)
cattle_lot_Poly_sps <- SpatialPolygons(list(cattle_lot_Poly_ps))
proj4string(cattle_lot_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_cattle_lot = SpatialPolygonsDataFrame(cattle_lot_Poly_sps,data)
spdf_cattle_lot
summary(spdf_cattle_lot)

# Set as simple feature
spdf_cattle_lot <- st_as_sf(spdf_cattle_lot)
spdf_cattle_lot <- st_transform(spdf_cattle_lot, st_crs(sampling_area))
spdf_cattle_lot <- st_as_sf(spdf_cattle_lot)
class(spdf_cattle_lot)

#######################################################################################################################
#Slough
# Replace these values with your DMS coordinates for the five points
lon_deg <- c(96, 96, 96, 96, 96, 96, 96, 96)
lon_min <- c(55, 55, 55, 55, 55, 55, 55, 55)
lon_sec <- c(55.75,57.18, 58.65, 59.40, 59.63, 58.85, 58.56,57.31) 
lon_dir <- rep("W", 8)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30, 30, 30, 30, 30)
lat_min <- c(44, 44, 44, 44, 44, 44, 44, 44)
lat_sec <- c(32.23, 34.20, 36.35, 36.65, 35.98, 35.44,34.63, 33.71)
lat_dir <- rep("N", 8)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create a dataframe for lot' coordinates
# Create an sf polygon object from the five points (assumes a closed polygon)
slough <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[5], lat_dd[5]),  # Point 5
                                         c(lon_dd[6], lat_dd[6]),  # Point 6
                                         c(lon_dd[7], lat_dd[7]),  # Point 7
                                         c(lon_dd[8], lat_dd[8]),  # Point 8
                                         c(lon_dd[1], lat_dd[1]))))

slough_Poly <- Polygon(slough)
slough_Poly_ps <- Polygons(list(slough_Poly),1)
slough_Poly_sps <- SpatialPolygons(list(slough_Poly_ps))
proj4string(slough_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_slough = SpatialPolygonsDataFrame(slough_Poly_sps,data)
spdf_slough
summary(spdf_slough)

# Set as simple feature
spdf_slough <- st_as_sf(spdf_slough)
spdf_slough <- st_transform(spdf_slough, st_crs(sampling_area))
spdf_slough <- st_as_sf(spdf_slough)

####################################################################################################################
# Step 4: Convert raster data to a data frame
raster_df <- as.data.frame(raster_data, xy = TRUE)
raster_df$Elev_Feet <- raster_df$Layer_1*3.28084

# Step 6: Clip the raster using the land parcel polygon
raster_clip <- crop(raster_data, st_buffer(sampling_area, dist = 20))

# Step 7: Save the raster layer to a Geotiff file
writeRaster(raster_clip, filename = "raster_MainPasture_prop.tif", format = "GTiff", overwrite= TRUE)

# Step 8; Load DEM tiff
elevation_mainpasture <- raster("raster_MainPasture_prop.tif")

# Convert the raster data to a data.frame
elevation_mainpasture_df <- raster::rasterToPoints(elevation_mainpasture)
elevation_mainpasture_df <- as.data.frame(elevation_mainpasture_df)
plot(raster_clip)

#####################################################################################################################################
#Creek
library(sf)
library(ggplot2)

# DMS to Decimal Degrees conversion function
dms_to_decimal <- function(dms) {
  degrees <- as.numeric(sub("([0-9]+)°.*", "\\1", dms))
  minutes <- as.numeric(sub("[0-9]+°([0-9]+)'.*", "\\1", dms))
  seconds <- as.numeric(sub("[0-9]+°[0-9]+'([0-9.]+)\".*", "\\1", dms))
  
  sign <- ifelse(grepl("W|S", dms), -1, 1)
  abs_decimal <- abs(degrees) + minutes/60 + seconds/3600
  sign * abs_decimal
}

# DMS coordinates for the polyline
y_dms <- c("30°44'26.81\" N", "30°44'24.93\" N", "30°44'22.58\" N", "30°44'20.90\" N", "30°44'21.86\" N", "30°44'21.60\" N", "30°44'22.87\" N", "30°44'22.70\" N", "30°44'22.27\" N")
x_dms <- c("96°56'4.19\" W",  "96°56'1.54\" W",  "96°56'1.70\" W",  "96°55'59.13\" W", "96°55'57.57\" W", "96°55'56.23\" W", "96°55'54.40\" W", "96°55'52.35\" W", "96°55'50.64\" W")

# Convert DMS to Decimal Degrees for x and y coordinates
x_decimal <- dms_to_decimal(x_dms)
y_decimal <- dms_to_decimal(y_dms)

# Create a data frame containing the Decimal Degrees coordinates for the polyline
polyline_data <- data.frame(X = x_decimal, Y = y_decimal)
polyline_data$point <- 1:nrow(polyline_data)

# Sort the data frame based on the "point" column
polyline_data_ordered <- polyline_data[order(polyline_data$point), ]

# Convert the data frame to a LINESTRING spatial object using sf
polyline_sf <- st_sfc(st_linestring(as.matrix(polyline_data_ordered[, c("X", "Y")]), dim = "XY"), crs = 4326)

# Create a buffer around the line (10 meters)
buffer_size <- 20  # 10 meters
buffer_sf <- st_buffer(polyline_sf, dist = buffer_size)
plot(buffer_sf)
st_as_sf(buffer_sf)
class(buffer_sf)

#####################################################################################################################################
#Slough
library(sf)
library(ggplot2)

# DMS to Decimal Degrees conversion function
dms_to_decimal <- function(dms) {
  degrees <- as.numeric(sub("([0-9]+)°.*", "\\1", dms))
  minutes <- as.numeric(sub("[0-9]+°([0-9]+)'.*", "\\1", dms))
  seconds <- as.numeric(sub("[0-9]+°[0-9]+'([0-9.]+)\".*", "\\1", dms))
  
  sign <- ifelse(grepl("W|S", dms), -1, 1)
  abs_decimal <- abs(degrees) + minutes/60 + seconds/3600
  sign * abs_decimal
}

# DMS coordinates for the polyline
y_dms <- c("30°44'36.10\" N", "30°44'31.34\" N", "30°44'28.14\" N", "30°44'26.27\" N", "30°44'22.87\" N")
x_dms <- c("96°55'59.07\" W", "96°55'54.53\" W", "96°55'54.48\" W", "96°55'56.00\" W", "96°55'54.40\" W")

# Convert DMS to Decimal Degrees for x and y coordinates
x_decimal <- dms_to_decimal(x_dms)
y_decimal <- dms_to_decimal(y_dms)

# Create a data frame containing the Decimal Degrees coordinates for the slough_polyline
slough_polyline_data <- data.frame(X = x_decimal, Y = y_decimal)
slough_polyline_data$point <- 1:nrow(slough_polyline_data)

# Sort the data frame based on the "point" column
slough_polyline_data_ordered <- slough_polyline_data[order(slough_polyline_data$point), ]

# Convert the data frame to a LINESTRING spatial object using sf
slough_polyline_sf <- st_sfc(st_linestring(as.matrix(slough_polyline_data_ordered[, c("X", "Y")]), dim = "XY"), crs = 4326)

# Create a buffer_slough around the line (10 meters)
buffer_slough_size <- 20  # 10 meters
buffer_slough_sf <- st_buffer(slough_polyline_sf, dist = buffer_slough_size)
plot(buffer_slough_sf)
st_as_sf(buffer_slough_sf)
class(buffer_slough_sf)

#####################################################################################################################################
#Catfish tank creek
library(sf)
library(ggplot2)

# DMS to Decimal Degrees conversion function
dms_to_decimal <- function(dms) {
  degrees <- as.numeric(sub("([0-9]+)°.*", "\\1", dms))
  minutes <- as.numeric(sub("[0-9]+°([0-9]+)'.*", "\\1", dms))
  seconds <- as.numeric(sub("[0-9]+°[0-9]+'([0-9.]+)\".*", "\\1", dms))
  
  sign <- ifelse(grepl("W|S", dms), -1, 1)
  abs_decimal <- abs(degrees) + minutes/60 + seconds/3600
  sign * abs_decimal
}

# DMS coordinates for the polyline
y_dms <- c("30°44'47.32\" N", "30°44'43.13\" N")
x_dms <- c("96°55'47.15\" W", "96°55'47.98\" W")

# Convert DMS to Decimal Degrees for x and y coordinates
x_decimal <- dms_to_decimal(x_dms)
y_decimal <- dms_to_decimal(y_dms)

# Create a data frame containing the Decimal Degrees coordinates for the catfish_creek_polyline
catfish_creek_polyline_data <- data.frame(X = x_decimal, Y = y_decimal)
catfish_creek_polyline_data$point <- 1:nrow(catfish_creek_polyline_data)

# Sort the data frame based on the "point" column
catfish_creek_polyline_data_ordered <- catfish_creek_polyline_data[order(catfish_creek_polyline_data$point), ]

# Convert the data frame to a LINESTRING spatial object using sf
catfish_creek_polyline_sf <- st_sfc(st_linestring(as.matrix(catfish_creek_polyline_data_ordered[, c("X", "Y")]), dim = "XY"), crs = 4326)

# Create a buffer_catfish_creek around the line (10 meters)
buffer_catfish_creek_size <- 20  # 10 meters
buffer_catfish_creek_sf <- st_buffer(catfish_creek_polyline_sf, dist = buffer_catfish_creek_size)
plot(buffer_catfish_creek_sf)
st_as_sf(buffer_catfish_creek_sf)
class(buffer_catfish_creek_sf)

#####################################################################################################################################
# Define the sampling area within the property boundaries (can be the entire property or a specific region)
sampling_area <- st_as_sf(morgan_prop_sf)
sampling_area <- st_transform(sampling_area, st_crs(morgan_prop_sf))

sampling_area_excluded_ponds1 <- st_difference(sampling_area, spdf_pond_pond1)
plot(sampling_area_excluded_ponds1)

sampling_area_excluded_ponds12 <- st_difference(sampling_area_excluded_ponds1, spdf_pond_pond2)
plot(sampling_area_excluded_ponds12)

sampling_area_excluded_ponds123 <- st_difference(sampling_area_excluded_ponds12, spdf_pond_pond3)
plot(sampling_area_excluded_ponds123)

sampling_area_excluded_ponds1234 <- st_difference(sampling_area_excluded_ponds123, spdf_pond_pond4)
plot(sampling_area_excluded_ponds1234)

sampling_area_excluded_ponds_cattlelot <- st_difference(sampling_area_excluded_ponds1234, spdf_cattle_lot)
plot(sampling_area_excluded_ponds_cattlelot)

sampling_area_excluded_all <- st_difference(sampling_area_excluded_ponds_cattlelot, buffer_slough_sf)
plot(sampling_area_excluded_all)

sampling_area_excluded_all_1 <- st_difference(sampling_area_excluded_all, buffer_catfish_creek_sf)
plot(sampling_area_excluded_all_1)

sampling_area_excluded_all_wBuffer <- st_difference(sampling_area_excluded_all_1, buffer_sf)
plot(sampling_area_excluded_all_wBuffer)

# Generate equally spaced sampling points within the property boundaries based on sample number function
sampling_points <- st_sample(sampling_area_excluded_all_wBuffer, type = "regular", size = num_sampling_points)

# Extract longitude (X) and latitude (Y) values from the POINT geometry
sampling_points_df <- as.data.frame(st_coordinates(sampling_points))
names(sampling_points_df) <- c("X", "Y")  # Rename columns for clarity

# Add DMS coordinates to sampling_points_df_final data frame
sampling_points_df$Longitude_DMS <- decimal_to_dms_with_directions(sampling_points_df$X, "x")
sampling_points_df$Latitude_DMS <- decimal_to_dms_with_directions(sampling_points_df$Y, "y")

# Add a new column "Sample_Number" to the sampling_points_df_final data frame with the sampling numbers
sampling_points_df$Sample_Number <- 1:nrow(sampling_points_df)

#Create .csv file with sample points, coordinates, and number
MainPastureSamplingPoints <- write.csv(sampling_points_df, "MainPastureSamplingPoints.csv")

##########################################################################################################

# Calculate the centroid of the polygon
#Pond 1
tank_centroid_1 <- st_centroid(spdf_pond_pond1)

tank_centroid_df_1 <- st_coordinates(tank_centroid_1) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))

#Pond 2
tank_centroid_2 <- st_centroid(spdf_pond_pond2)

tank_centroid_df_2 <- st_coordinates(tank_centroid_2) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))
  
#Pond 3
tank_centroid_3 <- st_centroid(spdf_pond_pond3)

tank_centroid_df_3 <- st_coordinates(tank_centroid_3) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))
  
#Pond 4
tank_centroid_4 <- st_centroid(spdf_pond_pond4)

tank_centroid_df_4 <- st_coordinates(tank_centroid_4) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))

# Calculate the centroid of the polygon
cattle_lot_centroid <- st_centroid(spdf_cattle_lot)

cattle_lot_centroid_df <- st_coordinates(cattle_lot_centroid) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))

# Calculate the centroid of the polygon
slough_centroid <- st_centroid(spdf_slough)

slough_centroid_df <- st_coordinates(slough_centroid) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))

#####################################################################################################################################
# Plot the shapefile with ggplot2 and add the raster data as a background layer
MainPasture<- ggplot() +
  geom_raster(data = elevation_mainpasture_df, aes(x = x, y = y, fill = raster_MainPasture_prop*3.28084)) +    # Plot the raster data
  geom_sf(data = spdf_pond_pond1, fill = "lightblue") +
  geom_text(data = tank_centroid_df_1, aes(x = X, y = Y, label = "TANK"), color = "black", size = 2) +
  geom_sf(data = cropped_pond2, fill = "lightblue") +
  geom_text(data = tank_centroid_df_2, aes(x = X, y = Y, label = "TANK"), color = "black", size = 2, angle =20) +
  geom_sf(data = sampling_area, color = "black", fill = "transparent") +       # Plot the shapefile
  geom_sf(data = spdf_pond_pond3, fill = "lightblue") +
  geom_text(data = tank_centroid_df_3, aes(x = X, y = Y, label = "TANK"), color = "black", size = 2) +
  geom_sf(data = spdf_pond_pond4, fill = "lightblue") +
  geom_text(data = tank_centroid_df_4, aes(x = X, y = Y, label = "TANK"), color = "black", size = 2) +
  geom_polygon(data = cattle_lot, aes(x = X1, y = X2), fill = "orange") +
  geom_text(data = cattle_lot_centroid_df, aes(x = X, y = Y, label = "CATTLE LOT"), color = "black", nudge_y = 0.00025, size = 2) +
  geom_text(data = slough_centroid_df, aes(x = X, y = Y, label = "SLOUGH"), color = "black", size = 2) +
  geom_point(data = sampling_points_df, aes(x = X, y = Y), color = "red", size = 2) +  # Plot the final sampling points
  geom_text(data = sampling_points_df, aes(x = X, y = Y, label = Sample_Number), 
            color = "black", nudge_x = -0.00025, nudge_y=-0.00025 ) +                # Adding labels to the sampling points
  scale_fill_viridis_c() +                                                              # Use Viridis color scale (you can change this)
  coord_sf(crs = st_crs(sampling_area)) +                                     # Set the coordinate system for the plot
  labs(x = "Longitude", y = "Latitude", fill = "Elevation (ft)", title = "Main Pasture DEM w/ Sampling Locations") + # Add the following line to set the desired breaks on the x-axis
  scale_x_continuous(labels = function(x) decimal_to_dms_with_directions(x, "x"), expand = c(0, 0)) +
  scale_y_continuous(labels = function(y) decimal_to_dms_with_directions(y, "y"), expand = c(0, 0)) +  # Use custom labeling for Y-axis
  theme(axis.title.x = element_text(size = 12, color = "black"),
        axis.text.x = element_text(size = 7, color = "black"),
        axis.title.y = element_text(size = 12, color = "black"),
        axis.text.y = element_text(size = 7, color = "black"),
        legend.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.justification = "center", 
        plot.title = element_text(hjust = 0.5))
MainPasture

ggsave("DEM_Sampling_MainPasture.jpeg", MainPasture ,height = 7, width = 7, dpi = 300)
```

# Mudcat and Perch Tank
```{r}
# Step 1: Load the required libraries
library(raster)
library(rgdal)
library(ggplot2)
library(scales)
library(sf)
library(sp)
library(terra)
library(rasterVis)
library(ggspatial)

# Step 2: Read the raster data and land parcel polygon shapefile
#raster_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/USGS_one_meter_x69y340_TX_Eastern_B1_2018.tif"
raster_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/USGS_13_n31w097_20191107.tif"
parcel_path <- "G:/Soil Sci 585/HW2/Soil-585/Homework 2/stratmap22-landparcels_48331_milam_202202.shp"

raster_data <- raster(raster_path)
parcel_data <- readOGR(parcel_path)

# Replace these values with your DMS coordinates for the five points
lon_deg <- c(96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96)
lon_min <- c(55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55)
lon_sec <- c(38.19, 39.60, 40.98, 32.87, 30.51, 25.51, 20.60, 22.72, 22.06, 32.88, 34.08)
lon_dir <- rep("W", 11)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30)
lat_min <- c(44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44)
lat_sec <- c(26.64, 34.86, 49.17, 51.51, 45.36, 46.58, 32.70, 32.09, 30.67, 27.60, 27.99)
lat_dir <- rep("N", 11)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create a dataframe for lot' coordinates
# Create an sf polygon object from the five points (assumes a closed polygon)
morgan_prop <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[5], lat_dd[5]),  # Point 5
                                         c(lon_dd[6], lat_dd[6]),  # Point 6
                                         c(lon_dd[7], lat_dd[7]),  # Point 7
                                         c(lon_dd[8], lat_dd[8]),  # Point 8
                                         c(lon_dd[9], lat_dd[9]),  # Point 9
                                         c(lon_dd[10], lat_dd[10]),  # Point 10
                                         c(lon_dd[11], lat_dd[11]),  # Point 11
                                         c(lon_dd[1], lat_dd[1]))))

morgan_prop_Poly <- Polygon(morgan_prop)
morgan_prop_Poly_ps <- Polygons(list(morgan_prop_Poly),1)
morgan_prop_Poly_sps <- SpatialPolygons(list(morgan_prop_Poly_ps))
proj4string(morgan_prop_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_morgan_prop = SpatialPolygonsDataFrame(morgan_prop_Poly_sps,data)
spdf_morgan_prop
summary(spdf_morgan_prop)

# Set as simple feature
spdf_morgan_prop <- st_as_sf(spdf_morgan_prop)
spdf_morgan_prop <- st_transform(spdf_morgan_prop, st_crs(sampling_area))
spdf_morgan_prop <- st_as_sf(spdf_morgan_prop)
class(spdf_morgan_prop)

# Step 3: Set the CRS of the shapefile to match the CRS of the raster
projection(raster_data) <- CRS("+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")
projection(raster_data)

morgan_prop_sf <- st_as_sf(spdf_morgan_prop)
sampling_area <- morgan_prop_sf

#####################################################################################
# Function to convert decimal degrees to DMS format with cardinal directions
decimal_to_dms_with_directions <- function(decimal_degrees, axis) {
  degrees <- floor(abs(decimal_degrees))
  minutes <- floor((abs(decimal_degrees) - degrees) * 60)
  seconds <- round((abs(decimal_degrees) - degrees - minutes/60) * 3600, 2)
  
  direction <- ifelse(axis == "x", ifelse(decimal_degrees < 0, "W", "E"), ifelse(decimal_degrees < 0, "S", "N"))
  
  return(paste0(degrees, "°", minutes, "'", seconds, "\" ", direction))
}

#####################################################################################
# Function to convert DMS (Degrees-Minutes-Seconds) to decimal degrees (DD)
dms_to_dd <- function(degrees, minutes, seconds, direction) {
  sign <- ifelse(direction %in% c("S", "W"), -1, 1)
  dd <- sign * (abs(degrees) + minutes / 60 + seconds / 3600)
  return(dd)
}

# Function to convert meters to decimal degrees
meters_to_dd <- function(meters, latitude) {
  # Earth's radius in meters
  earth_radius <- 6378137
  
  # Conversion factor (approximation for small distances)
  meters_per_degree <- (2 * pi * earth_radius) / 360
  
  # Calculate the distance in decimal degrees
  dd <- meters / meters_per_degree
  
  return(dd)
}
#####################################################################################
# Creating function to create number of samples per area
set_sampling_points <- function(polygon_sf) {
  # Get the total area of the polygon in acres from the "GIS_AREA" column
  total_area_acres <- sum(polygon_sf$GIS_AREA)
  
  # Set the number of sampling points based on the area criteria
  if (total_area_acres <= 1) {
    num_sampling_points <- 10
  } else if (total_area_acres > 1 & total_area_acres <= 5) {
    num_sampling_points <- round(total_area_acres * 2)
  } else if (total_area_acres > 5 & total_area_acres <= 20) {
    num_sampling_points <- round(total_area_acres / 2)
  } else {
    num_sampling_points <- round(total_area_acres/10)
  }
  
  return(num_sampling_points)
}

# Assuming you have the "morgan_prop_sf" data frame with the column "GIS_AREA"
num_sampling_points <- set_sampling_points(sampling_area)

print(num_sampling_points)  # This will give you the number of sampling points based on the area of the polygons and the specified criteria

####################################################################################
# Step 4: Convert raster data to a data frame
raster_df <- as.data.frame(raster_data, xy = TRUE)

crs(sampling_area)

#####################################################################################################################################
# Buffer distance in meters
buffer_distance_meters <- 30

#Pond 1
# Example of pond_location in DMS format
lon_deg_pond1 <- 96
lon_min_pond1 <- 55
lon_sec_pond1 <- 38.10
lon_dir_pond1 <- "W"  # West (use "E" for East)

lat_deg_pond1 <- 30
lat_min_pond1 <- 44
lat_sec_pond1 <- 38.43
lat_dir_pond1 <- "N"  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude
lon_pond_dd_pond1 <- dms_to_dd(lon_deg_pond1, lon_min_pond1, lon_sec_pond1, lon_dir_pond1)
lat_pond_dd_pond1 <- dms_to_dd(lat_deg_pond1, lat_min_pond1, lat_sec_pond1, lat_dir_pond1)

# Convert buffer distance from meters to decimal degrees
buffer_distance_dd_pond1 <- meters_to_dd(buffer_distance_meters, lat_pond_dd_pond1)

# Create the pond_location as a point in sf format
pond_central_point_pond1 <- st_point(c(lon_pond_dd_pond1, lat_pond_dd_pond1))

# Add a buffer of 50 meters around the pond_central_point
pond_buffer_pond1 <- st_buffer(pond_central_point_pond1, dist = buffer_distance_dd_pond1, crs = "+init=epsg:4326")

# Extract the x (longitude) and y (latitude) coordinates from the circle
circle_coords_pond1 <- st_coordinates(pond_buffer_pond1)

# Create a dataframe with the circle coordinates
circle_df_pond1 <- data.frame(lon = circle_coords_pond1[, "X"], lat = circle_coords_pond1[, "Y"])

pond_boundary_Poly_pond1 <- Polygon(circle_df_pond1)
pond_boundary_Poly_ps_pond1 <- Polygons(list(pond_boundary_Poly_pond1),1)
pond_boundary_Poly_sps_pond1 <- SpatialPolygons(list(pond_boundary_Poly_ps_pond1))
plot(pond_boundary_Poly_sps_pond1)
proj4string(pond_boundary_Poly_sps_pond1) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

data = data.frame(f=99.9)
spdf_pond_pond1 = SpatialPolygonsDataFrame(pond_boundary_Poly_sps_pond1,data)
spdf_pond_pond1
summary(spdf_pond_pond1)

spdf_pond_pond1 <- st_as_sf(spdf_pond_pond1)
spdf_pond_pond1 <- st_transform(spdf_pond_pond1, st_crs(sampling_area))


#Pond 2
# Example of pond_location in DMS format
lon_deg_pond2 <- 96
lon_min_pond2 <- 55
lon_sec_pond2 <- 30.11
lon_dir_pond2 <- "W"  # West (use "E" for East)

lat_deg_pond2 <- 30
lat_min_pond2 <- 44
lat_sec_pond2 <- 30.99
lat_dir_pond2 <- "N"  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude
lon_pond_dd_pond2 <- dms_to_dd(lon_deg_pond2, lon_min_pond2, lon_sec_pond2, lon_dir_pond2)
lat_pond_dd_pond2 <- dms_to_dd(lat_deg_pond2, lat_min_pond2, lat_sec_pond2, lat_dir_pond2)

# Convert buffer distance from meters to decimal degrees
buffer_distance_dd_pond2 <- meters_to_dd(buffer_distance_meters, lat_pond_dd_pond2)

# Create the pond_location as a point in sf format
pond_central_point_pond2 <- st_point(c(lon_pond_dd_pond2, lat_pond_dd_pond2))

# Add a buffer of 50 meters around the pond_central_point
pond_buffer_pond2 <- st_buffer(pond_central_point_pond2, dist = buffer_distance_dd_pond2, crs = "+init=epsg:4326")

# Extract the x (longitude) and y (latitude) coordinates from the circle
circle_coords_pond2 <- st_coordinates(pond_buffer_pond2)

# Create a dataframe with the circle coordinates
circle_df_pond2 <- data.frame(lon = circle_coords_pond2[, "X"], lat = circle_coords_pond2[, "Y"])

pond_boundary_Poly_pond2 <- Polygon(circle_df_pond2)
pond_boundary_Poly_ps_pond2 <- Polygons(list(pond_boundary_Poly_pond2),1)
pond_boundary_Poly_sps_pond2 <- SpatialPolygons(list(pond_boundary_Poly_ps_pond2))
plot(pond_boundary_Poly_sps_pond2)
proj4string(pond_boundary_Poly_sps_pond2) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

data = data.frame(f=99.9)
spdf_pond_pond2 = SpatialPolygonsDataFrame(pond_boundary_Poly_sps_pond2,data)
spdf_pond_pond2
summary(spdf_pond_pond2)

spdf_pond_pond2 <- st_as_sf(spdf_pond_pond2)
spdf_pond_pond2 <- st_transform(spdf_pond_pond2, st_crs(sampling_area))


#Pond 3
# Example of pond_location in DMS format
lon_deg_pond3 <- 96
lon_min_pond3 <- 55
lon_sec_pond3 <- 25
lon_dir_pond3 <- "W"  # West (use "E" for East)

lat_deg_pond3 <- 30
lat_min_pond3 <- 44
lat_sec_pond3 <- 40.35
lat_dir_pond3 <- "N"  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude
lon_pond_dd_pond3 <- dms_to_dd(lon_deg_pond3, lon_min_pond3, lon_sec_pond3, lon_dir_pond3)
lat_pond_dd_pond3 <- dms_to_dd(lat_deg_pond3, lat_min_pond3, lat_sec_pond3, lat_dir_pond3)

# Convert buffer distance from meters to decimal degrees
buffer_distance_dd_pond3 <- meters_to_dd(buffer_distance_meters, lat_pond_dd_pond3)

# Create the pond_location as a point in sf format
pond_central_point_pond3 <- st_point(c(lon_pond_dd_pond3, lat_pond_dd_pond3))

# Add a buffer of 50 meters around the pond_central_point
pond_buffer_pond3 <- st_buffer(pond_central_point_pond3, dist = buffer_distance_dd_pond3, crs = "+init=epsg:4326")

# Extract the x (longitude) and y (latitude) coordinates from the circle
circle_coords_pond3 <- st_coordinates(pond_buffer_pond3)

# Create a dataframe with the circle coordinates
circle_df_pond3 <- data.frame(lon = circle_coords_pond3[, "X"], lat = circle_coords_pond3[, "Y"])

pond_boundary_Poly_pond3 <- Polygon(circle_df_pond3)
pond_boundary_Poly_ps_pond3 <- Polygons(list(pond_boundary_Poly_pond3),1)
pond_boundary_Poly_sps_pond3 <- SpatialPolygons(list(pond_boundary_Poly_ps_pond3))
plot(pond_boundary_Poly_sps_pond3)
proj4string(pond_boundary_Poly_sps_pond3) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

data = data.frame(f=99.9)
spdf_pond_pond3 = SpatialPolygonsDataFrame(pond_boundary_Poly_sps_pond3,data)
spdf_pond_pond3
summary(spdf_pond_pond3)

spdf_pond_pond3 <- st_as_sf(spdf_pond_pond3)
spdf_pond_pond3 <- st_transform(spdf_pond_pond3, st_crs(sampling_area))


#################################################################################################################
# Mudcat Tank
# Replace these values with your DMS coordinates for the five points
lon_deg <- c(96, 96, 96, 96, 96, 96, 96)
lon_min <- c(55, 55, 55, 55, 55, 55, 55)
lon_sec <- c(39.60, 40.98, 32.87, 31.49, 32.53, 30.52, 35.15)
lon_dir <- rep("W", 7)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30, 30, 30, 30)
lat_min <- c(44, 44, 44, 44, 44, 44, 44)
lat_sec <- c(34.86,49.17,51.51, 47.99, 45.70, 38.52, 37.73)
lat_dir <- rep("N", 7)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create a dataframe for lot' coordinates
# Create an sf polygon object from the five points (assumes a closed polygon)
mudcat_land <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[5], lat_dd[5]),  # Point 5
                                         c(lon_dd[6], lat_dd[6]),  # Point 6
                                         c(lon_dd[7], lat_dd[7]),  # Point 7
                                         c(lon_dd[1], lat_dd[1]))))

mudcat_land_Poly <- Polygon(mudcat_land)
mudcat_land_Poly_ps <- Polygons(list(mudcat_land_Poly),1)
mudcat_land_Poly_sps <- SpatialPolygons(list(mudcat_land_Poly_ps))
proj4string(mudcat_land_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_mudcat_land = SpatialPolygonsDataFrame(mudcat_land_Poly_sps,data)
spdf_mudcat_land
summary(spdf_mudcat_land)

# Set as simple feature
spdf_mudcat_land <- st_as_sf(spdf_mudcat_land)
spdf_mudcat_land <- st_transform(spdf_mudcat_land, st_crs(sampling_area))
spdf_mudcat_land <- st_as_sf(spdf_mudcat_land)
class(spdf_mudcat_land)

#######################################################################################################################
#Oil well
# Replace these values with your DMS coordinates for the five points
lon_deg <- c(96, 96, 96, 96)
lon_min <- c(55, 55, 55, 55)
lon_sec <- c(20.60,20.19, 22.06, 22.72) 
lon_dir <- rep("W", 4)  # West (use "E" for East)

lat_deg <- c(30, 30, 30, 30)
lat_min <- c(44, 44, 44, 44)
lat_sec <- c(32.70, 31.40, 30.67, 32.09)
lat_dir <- rep("N", 4)  # North (use "S" for South)

# Convert DMS to decimal degrees (DD) for longitude and latitude for all five points
lon_dd <- dms_to_dd(lon_deg, lon_min, lon_sec, lon_dir)
lat_dd <- dms_to_dd(lat_deg, lat_min, lat_sec, lat_dir)

# Create a dataframe for lot' coordinates
# Create an sf polygon object from the five points (assumes a closed polygon)
oilwell <- as.data.frame(list(rbind(c(lon_dd[1], lat_dd[1]),  # Point 1
                                         c(lon_dd[2], lat_dd[2]),  # Point 2
                                         c(lon_dd[3], lat_dd[3]),  # Point 3
                                         c(lon_dd[4], lat_dd[4]),  # Point 4
                                         c(lon_dd[1], lat_dd[1]))))

oilwell_Poly <- Polygon(oilwell)
oilwell_Poly_ps <- Polygons(list(oilwell_Poly),1)
oilwell_Poly_sps <- SpatialPolygons(list(oilwell_Poly_ps))
proj4string(oilwell_Poly_sps) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
data = data.frame(f=99.9)
spdf_oilwell = SpatialPolygonsDataFrame(oilwell_Poly_sps,data)
spdf_oilwell
summary(spdf_oilwell)

# Set as simple feature
spdf_oilwell <- st_as_sf(spdf_oilwell)
spdf_oilwell <- st_transform(spdf_oilwell, st_crs(sampling_area))
spdf_oilwell <- st_as_sf(spdf_oilwell)

####################################################################################################################
# Step 4: Convert raster data to a data frame
raster_df <- as.data.frame(raster_data, xy = TRUE)
raster_df$Elev_Feet <- raster_df$Layer_1*3.28084

# Step 6: Clip the raster using the land parcel polygon
raster_clip <- crop(raster_data, st_buffer(sampling_area, dist = 20))

# Step 7: Save the raster layer to a Geotiff file
writeRaster(raster_clip, filename = "raster_MudcatPerchLand_prop.tif", format = "GTiff", overwrite= TRUE)

# Step 8; Load DEM tiff
elevation_MudcatPerchLand <- raster("raster_MudcatPerchLand_prop.tif")

# Convert the raster data to a data.frame
elevation_MudcatPerchLand_df <- raster::rasterToPoints(elevation_MudcatPerchLand)
elevation_MudcatPerchLand_df <- as.data.frame(elevation_MudcatPerchLand_df)
plot(raster_clip)

#####################################################################################################################################
#Creek
library(sf)
library(ggplot2)

# DMS to Decimal Degrees conversion function
dms_to_decimal <- function(dms) {
  degrees <- as.numeric(sub("([0-9]+)°.*", "\\1", dms))
  minutes <- as.numeric(sub("[0-9]+°([0-9]+)'.*", "\\1", dms))
  seconds <- as.numeric(sub("[0-9]+°[0-9]+'([0-9.]+)\".*", "\\1", dms))
  
  sign <- ifelse(grepl("W|S", dms), -1, 1)
  abs_decimal <- abs(degrees) + minutes/60 + seconds/3600
  sign * abs_decimal
}

# DMS coordinates for the polyline
y_dms <- c("30°44'26.81\" N", "30°44'24.93\" N", "30°44'22.58\" N", "30°44'20.90\" N", "30°44'21.86\" N", "30°44'21.60\" N", "30°44'22.87\" N", "30°44'22.70\" N", "30°44'22.27\" N")
x_dms <- c("96°56'4.19\" W",  "96°56'1.54\" W",  "96°56'1.70\" W",  "96°55'59.13\" W", "96°55'57.57\" W", "96°55'56.23\" W", "96°55'54.40\" W", "96°55'52.35\" W", "96°55'50.64\" W")

# Convert DMS to Decimal Degrees for x and y coordinates
x_decimal <- dms_to_decimal(x_dms)
y_decimal <- dms_to_decimal(y_dms)

# Create a data frame containing the Decimal Degrees coordinates for the polyline
polyline_data <- data.frame(X = x_decimal, Y = y_decimal)
polyline_data$point <- 1:nrow(polyline_data)

# Sort the data frame based on the "point" column
polyline_data_ordered <- polyline_data[order(polyline_data$point), ]

# Convert the data frame to a LINESTRING spatial object using sf
polyline_sf <- st_sfc(st_linestring(as.matrix(polyline_data_ordered[, c("X", "Y")]), dim = "XY"), crs = 4326)

# Create a buffer around the line (10 meters)
buffer_size <- 20  # 10 meters
buffer_sf <- st_buffer(polyline_sf, dist = buffer_size)
plot(buffer_sf)
st_as_sf(buffer_sf)
class(buffer_sf)

#####################################################################################################################################
# Define the sampling area within the property boundaries (can be the entire property or a specific region)
sampling_area <- st_as_sf(morgan_prop_sf)
sampling_area <- st_transform(sampling_area, st_crs(morgan_prop_sf))

sampling_area_excluded_ponds1 <- st_difference(sampling_area, spdf_pond_pond1)
plot(sampling_area_excluded_ponds1)

sampling_area_excluded_ponds12 <- st_difference(sampling_area_excluded_ponds1, spdf_pond_pond2)
plot(sampling_area_excluded_ponds12)

sampling_area_excluded_ponds123 <- st_difference(sampling_area_excluded_ponds12, spdf_pond_pond3)
plot(sampling_area_excluded_ponds123)

sampling_area_excluded_ponds123_mudcat <- st_difference(sampling_area_excluded_ponds123, spdf_mudcat_land)
plot(sampling_area_excluded_ponds123_mudcat)

sampling_area_excluded_all <- st_difference(sampling_area_excluded_ponds123_mudcat, spdf_oilwell)
plot(sampling_area_excluded_all)

# Generate equally spaced sampling points within the property boundaries based on sample number function
sampling_points <- st_sample(sampling_area_excluded_all, type = "regular", size = num_sampling_points)

# Extract longitude (X) and latitude (Y) values from the POINT geometry
sampling_points_df <- as.data.frame(st_coordinates(sampling_points))
names(sampling_points_df) <- c("X", "Y")  # Rename columns for clarity

# Add DMS coordinates to sampling_points_df_final data frame
sampling_points_df$Longitude_DMS <- decimal_to_dms_with_directions(sampling_points_df$X, "x")
sampling_points_df$Latitude_DMS <- decimal_to_dms_with_directions(sampling_points_df$Y, "y")

# Add a new column "Sample_Number" to the sampling_points_df_final data frame with the sampling numbers
sampling_points_df$Sample_Number <- 1:nrow(sampling_points_df)

#Create .csv file with sample points, coordinates, and number
MudcatPerchLandSamplingPoints <- write.csv(sampling_points_df, "MudcatPerchLandSamplingPoints.csv")

##########################################################################################################

# Calculate the centroid of the polygon
#Pond 1
tank_centroid_1 <- st_centroid(spdf_pond_pond1)

tank_centroid_df_1 <- st_coordinates(tank_centroid_1) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))

#Pond 2
tank_centroid_2 <- st_centroid(spdf_pond_pond2)

tank_centroid_df_2 <- st_coordinates(tank_centroid_2) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))
  
#Pond 3
tank_centroid_3 <- st_centroid(spdf_pond_pond3)

tank_centroid_df_3 <- st_coordinates(tank_centroid_3) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))
  

# Calculate the centroid of the polygon
mudcat_land_centroid <- st_centroid(spdf_mudcat_land)

mudcat_land_centroid_df <- st_coordinates(mudcat_land_centroid) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))

# Calculate the centroid of the polygon
oilwell_centroid <- st_centroid(spdf_oilwell)

oilwell_centroid_df <- st_coordinates(oilwell_centroid) %>%
  as.data.frame() %>%
  setNames(c("X", "Y"))


# Manually specify the three specific values for the breaks on the x-axis (DMS format)
breaks_x <- c(-96.931, -96.92625,-96.922, -96.91775)

#####################################################################################################################################
# Plot the shapefile with ggplot2 and add the raster data as a background layer
MudcatPerchLand<- ggplot() +
  geom_raster(data = elevation_MudcatPerchLand_df, aes(x = x, y = y, fill = raster_MudcatPerchLand_prop*3.28084)) +    # Plot the raster data
  geom_polygon(data = mudcat_land, aes(x = X1, y = X2), fill = "orange") +
  geom_text(data = mudcat_land_centroid_df, aes(x = X, y = Y, label = "Mudcat Tank Land (Trees)"), color = "black", size = 2) +
  geom_sf(data = sampling_area, color = "black", fill = "transparent") +       # Plot the shapefile
  geom_sf(data = spdf_pond_pond1, fill = "lightblue") +
  geom_text(data = tank_centroid_df_1, aes(x = X, y = Y, label = "TANK"), color = "black", size = 2) +
  geom_sf(data = spdf_pond_pond2, fill = "lightblue") +
  geom_text(data = tank_centroid_df_2, aes(x = X, y = Y, label = "TANK"), color = "black", size = 2) +
  geom_sf(data = spdf_pond_pond3, fill = "lightblue") +
  geom_text(data = tank_centroid_df_3, aes(x = X, y = Y, label = "TANK"), color = "black", size = 2) +
  geom_polygon(data = oilwell, aes(x = X1, y = X2), fill = "yellow") +
  geom_text(data = oilwell_centroid_df, aes(x = X, y = Y, label = "Oil Well"), color = "black", size = 2) +
  geom_point(data = sampling_points_df, aes(x = X, y = Y), color = "red", size = 2) +  # Plot the final sampling points
  geom_text(data = sampling_points_df, aes(x = X, y = Y, label = Sample_Number), 
            color = "black", vjust = 0, hjust = -0.5) +                # Adding labels to the sampling points
  scale_fill_viridis_c() +                                                              # Use Viridis color scale (you can change this)
  coord_sf(crs = st_crs(sampling_area)) +                                     # Set the coordinate system for the plot
  labs(x = "Longitude", y = "Latitude", fill = "Elevation (ft)", title = "Mudcat and Perch Tank Pastures DEM w/ Sampling Locations") + # Add the following line to set the desired breaks on the x-axis
  scale_x_continuous(labels = function(x) decimal_to_dms_with_directions(x, "x"), expand = c(0, 0)) +
  scale_y_continuous(labels = function(y) decimal_to_dms_with_directions(y, "y"), expand = c(0, 0)) +  # Use custom labeling for Y-axis
  theme(axis.title.x = element_text(size = 12, color = "black"),
        axis.text.x = element_text(size = 7, color = "black"),
        axis.title.y = element_text(size = 12, color = "black"),
        axis.text.y = element_text(size = 7, color = "black"),
        legend.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.justification = "center", 
        plot.title = element_text(hjust = 0.5))
MudcatPerchLand

ggsave("DEM_Sampling_MudcatPerchLand.jpeg", MudcatPerchLand ,height = 7, width = 7, dpi = 300)
```


# Function to convert decimal degrees to DMS format with cardinal directions
```{r}
decimal_to_dms_with_directions <- function(decimal_degrees, axis) {
  degrees <- floor(abs(decimal_degrees))
  minutes <- floor((abs(decimal_degrees) - degrees) * 60)
  seconds <- round((abs(decimal_degrees) - degrees - minutes/60) * 3600, 2)
  
  direction <- ifelse(axis == "x", ifelse(decimal_degrees < 0, "W", "E"), ifelse(decimal_degrees < 0, "S", "N"))
  
  return(paste0(degrees, "°", minutes, "'", seconds, "\" ", direction))
}

# Generate equally spaced sampling points within the property boundaries based on sample number function
sampling_points <- st_sample(sampling_area, type = "regular", size = num_sampling_points)

# Extract longitude (X) and latitude (Y) values from the POINT geometry
sampling_points_df <- as.data.frame(st_coordinates(sampling_points))
names(sampling_points_df) <- c("X", "Y")  # Rename columns for clarity
```

# Function to convert DMS (Degrees-Minutes-Seconds) to decimal degrees (DD)
```{r}
dms_to_dd <- function(degrees, minutes, seconds, direction) {
  sign <- ifelse(direction %in% c("S", "W"), -1, 1)
  dd <- sign * (abs(degrees) + minutes / 60 + seconds / 3600)
  return(dd)
}

# Function to convert meters to decimal degrees
meters_to_dd <- function(meters, latitude) {
  # Earth's radius in meters
  earth_radius <- 6378137
  
  # Conversion factor (approximation for small distances)
  meters_per_degree <- (2 * pi * earth_radius) / 360
  
  # Calculate the distance in decimal degrees
  dd <- meters / meters_per_degree
  
  return(dd)
}
```
